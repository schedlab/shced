<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scheduler V1.9.4 (Dynamic)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.4.0/exceljs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
        body.rtl { font-family: 'Cairo', sans-serif; }
        .custom-scroll::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 4px; }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 rtl">
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // --- Helpers ---
        const STORAGE_KEY = 'scheduler_data_v1_14_dynamic';
        const OLD_STORAGE_KEYS = ['scheduler_data_v1_9_3', 'scheduler_data_v1_9_4'];
        const defaultShifts = [
            { id: 'morning', name: { en: 'Morning', ar: 'ØµØ¨Ø§Ø­ÙŠ' }, icon: 'â˜€ï¸', color: '#fef08a', defaultStartTime: '06:00', defaultEndTime: '14:00', enabled: true },
            { id: 'evening', name: { en: 'Evening', ar: 'Ù…Ø³Ø§Ø¦ÙŠ' }, icon: 'ðŸŒ†', color: '#bfdbfe', defaultStartTime: '14:00', defaultEndTime: '22:00', enabled: true },
            { id: 'night', name: { en: 'Night', ar: 'Ù„ÙŠÙ„ÙŠ' }, icon: 'ðŸŒ™', color: '#c7d2fe', defaultStartTime: '22:00', defaultEndTime: '06:00', enabled: true },
            { id: 'standby', name: { en: 'Standby', ar: 'Ø·ÙˆØ§Ø±Ø¦' }, icon: 'ðŸ›Ÿ', color: '#fecdd3', defaultStartTime: '00:00', defaultEndTime: '23:59', enabled: false },
        ];

        const defaultRequirements = () => Array.from({ length: 7 }).map(() => ({
            morning: { requiredCount: 2, startTime: '06:00', endTime: '14:00' },
            evening: { requiredCount: 2, startTime: '14:00', endTime: '22:00' },
            night: { requiredCount: 1, startTime: '22:00', endTime: '06:00' },
            standby: { requiredCount: 0, startTime: '00:00', endTime: '23:59' },
        }));

        const TRANSLATIONS = {
            en: {
                title: 'Dynamic Scheduler',
                tabs: { schedule: 'Schedule', availability: 'Availability', employees: 'Employees', settings: 'Settings', export: 'Export' },
                generate: 'Generate New',
                clear: 'Clear',
                availability: 'Availability & Preferences',
                employees: 'Employees',
                addEmployee: 'Add Employee',
                remove: 'Remove',
                shifts: 'Shifts',
                addShift: 'Add Shift',
                requirements: 'Requirements & Constraints',
                workDay: 'Work Day',
                holidays: 'Holidays',
                addHoliday: 'Add Holiday',
                export: 'Export',
                exportCsv: 'Export CSV',
                exportExcel: 'Export Excel',
                viewSettings: 'View Settings',
                fontSize: 'Font Size',
                cellPadding: 'Cell Padding',
                showTimes: 'Show Times in Header',
                excelOptions: 'Excel Header/Footer',
                office: 'Office Name',
                preparer: 'Prepared By',
                headerColor: 'Header Color',
                headerText: 'Header Text Color',
                showWarnings: 'Show Warnings',
            },
            ar: {
                title: 'Ù…Ù†Ø´Ø¦ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ',
                tabs: { schedule: 'Ø§Ù„Ø¬Ø¯ÙˆÙ„', availability: 'Ø§Ù„ØªÙˆÙØ±', employees: 'Ø§Ù„Ù…ÙˆØ¸ÙÙˆÙ†', settings: 'Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª', export: 'ØªØµØ¯ÙŠØ±' },
                generate: 'ØªÙˆÙ„ÙŠØ¯ Ø¬Ø¯ÙŠØ¯',
                clear: 'Ù…Ø³Ø­',
                availability: 'Ø§Ù„ØªÙˆÙØ± ÙˆØ§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª',
                employees: 'Ø§Ù„Ù…ÙˆØ¸ÙÙˆÙ†',
                addEmployee: 'Ø¥Ø¶Ø§ÙØ© Ù…ÙˆØ¸Ù',
                remove: 'Ø¥Ø²Ø§Ù„Ø©',
                shifts: 'Ø§Ù„ÙˆØ±Ø¯ÙŠØ§Øª',
                addShift: 'Ø¥Ø¶Ø§ÙØ© ÙˆØ±Ø¯ÙŠØ©',
                requirements: 'Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª ÙˆØ§Ù„Ù‚ÙŠÙˆØ¯',
                workDay: 'ÙŠÙˆÙ… Ø¹Ù…Ù„',
                holidays: 'Ø§Ù„Ø¹Ø·Ù„',
                addHoliday: 'Ø¥Ø¶Ø§ÙØ© Ø¹Ø·Ù„Ø©',
                export: 'ØªØµØ¯ÙŠØ±',
                exportCsv: 'ØªØµØ¯ÙŠØ± CSV',
                exportExcel: 'ØªØµØ¯ÙŠØ± Excel',
                viewSettings: 'Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø±Ø¶',
                fontSize: 'Ø­Ø¬Ù… Ø§Ù„Ø®Ø·',
                cellPadding: 'Ù‡Ø§Ù…Ø´ Ø§Ù„Ø®Ù„ÙŠØ©',
                showTimes: 'Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø£ÙˆÙ‚Ø§Øª ÙÙŠ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†',
                excelOptions: 'Ø±Ø£Ø³ ÙˆØªØ°ÙŠÙŠÙ„ Excel',
                office: 'Ø§Ø³Ù… Ø§Ù„Ù…ÙƒØªØ¨',
                preparer: 'Ø£Ø¹Ø¯ Ø¨ÙˆØ§Ø³Ø·Ø©',
                headerColor: 'Ù„ÙˆÙ† Ø§Ù„Ø±Ø£Ø³',
                headerText: 'Ù„ÙˆÙ† Ù†Øµ Ø§Ù„Ø±Ø£Ø³',
                showWarnings: 'Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª',
            },
        };

        const migrateLegacyData = () => {
            for (const key of OLD_STORAGE_KEYS) {
                const raw = localStorage.getItem(key);
                if (!raw) continue;
                try {
                    const parsed = JSON.parse(raw);
                    const migrated = {
                        language: parsed.language || 'en',
                        employees: parsed.employees || [],
                        shifts: defaultShifts,
                        requirements: defaultRequirements(),
                        availability: parsed.availability || {},
                        preferences: parsed.preferences || {},
                        schedule: {},
                        workDays: parsed.workDays || [0,1,2,3,4,5,6],
                        holidays: [],
                        constraints: parsed.constraints || {
                            maxConsecutiveWorkDays: 5,
                            minConsecutiveWorkDays: 1,
                            maxConsecutiveRestDays: 2,
                            minConsecutiveRestDays: 1,
                            minWorkDaysBetweenRests: 0,
                        },
                        mode: parsed.mode || 'month',
                        startDate: parsed.startDate || '',
                        endDate: parsed.endDate || '',
                        month: parsed.month || new Date().getMonth(),
                        year: parsed.year || new Date().getFullYear(),
                        excelOptions: parsed.excelOptions || {},
                        viewOptions: parsed.viewOptions || {},
                    };

                    if (parsed.requirements) {
                        migrated.requirements = Array.from({ length: 7 }).map((_, idx) => {
                            const old = parsed.requirements[idx] || {};
                            return {
                                morning: { requiredCount: old.morning?.count || old.morning || 0, startTime: old.morning?.start || '06:00', endTime: old.morning?.end || '14:00' },
                                evening: { requiredCount: old.night?.count || old.evening || 0, startTime: old.night?.start || '14:00', endTime: old.night?.end || '22:00' },
                                night: { requiredCount: old.nightShift?.count || old.nightShift || 0, startTime: old.nightShift?.start || '22:00', endTime: old.nightShift?.end || '06:00' },
                                standby: { requiredCount: old.standby?.count || old.standby || 0, startTime: old.standby?.start || '00:00', endTime: old.standby?.end || '23:59' },
                            };
                        });
                    }

                    if (parsed.schedule) {
                        const newSchedule = {};
                        Object.entries(parsed.schedule).forEach(([date, value]) => {
                            newSchedule[date] = {
                                morning: value.morning || [],
                                evening: value.night || value.evening || [],
                                night: value.nightShift || [],
                                standby: value.standby || [],
                            };
                        });
                        migrated.schedule = newSchedule;
                    }

                    localStorage.setItem(STORAGE_KEY, JSON.stringify(migrated));
                    return migrated;
                } catch (err) {
                    console.error('Legacy migration failed', err);
                }
            }
            return null;
        };

        const loadState = () => {
            const legacy = migrateLegacyData();
            if (legacy) return legacy;
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return null;
            try { return JSON.parse(raw); } catch (e) { return null; }
        };

        const saveState = (state) => localStorage.setItem(STORAGE_KEY, JSON.stringify(state));

        const daysShort = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const daysFull = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

        // --- YALPS stub ---
        const YALPS = {
            solve({ dates, employees, shifts, requirements, availability, preferences, workDays, holidays, constraints }) {
                const enabledShifts = shifts.filter(s => s.enabled);
                const assign = {};
                const loadCount = Object.fromEntries(employees.map(e => [e.id, 0]));
                const streaks = Object.fromEntries(employees.map(e => [e.id, []]));

                const isHoliday = (d) => holidays.includes(d);
                const dayAllowed = (d) => workDays.includes(new Date(d).getDay());

                const availableFor = (empId, date, shiftId) => {
                    const day = availability[empId]?.[date];
                    if (!day) return true;
                    if (day.status === 'unavailable') return false;
                    if (day.allowedShifts && day.allowedShifts.length > 0) {
                        return day.allowedShifts.includes(shiftId);
                    }
                    return true;
                };

                const preferenceScore = (empId, date, shiftId) => {
                    const pref = preferences[empId] || {};
                    let score = 0;
                    if (pref.preferredShifts?.includes(shiftId)) score += 1;
                    if (pref.priorityDays?.includes(new Date(date).getDay())) score += 1;
                    return score;
                };

                for (const date of dates) {
                    assign[date] = {};
                    if (!dayAllowed(date) || isHoliday(date)) {
                        enabledShifts.forEach(s => assign[date][s.id] = []);
                        continue;
                    }

                    const dayIndex = new Date(date).getDay();
                    const req = requirements[dayIndex] || {};

                    for (const shift of enabledShifts) {
                        const need = req[shift.id]?.requiredCount || 0;
                        assign[date][shift.id] = [];
                        if (need === 0) continue;
                        const candidates = employees
                            .filter(e => availableFor(e.id, date, shift.id))
                            .filter(e => !assign[date].__used?.includes(e.id));

                        for (let i = 0; i < need; i++) {
                            const pick = candidates
                                .filter(c => !(assign[date].__used || []).includes(c.id))
                                .map(c => ({
                                    emp: c.id,
                                    score: loadCount[c.id] + (constraints.fairnessWeight || 10) * 0 + preferenceScore(c.id, date, shift.id)
                                }))
                                .sort((a, b) => (a.score - b.score) || (loadCount[a.emp] - loadCount[b.emp]))[0];
                            if (!pick) return { feasible: false, reason: 'insufficient_candidates' };
                            assign[date][shift.id].push(pick.emp);
                            loadCount[pick.emp] = (loadCount[pick.emp] || 0) + 1;
                            assign[date].__used = [...(assign[date].__used || []), pick.emp];
                        }
                    }
                }

                // remove helper
                Object.values(assign).forEach(v => delete v.__used);
                return { feasible: true, solution: assign };
            }
        };

        const DateRange = ({ startDate, endDate }) => {
            const dates = [];
            const start = new Date(startDate);
            const end = new Date(endDate);
            for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                dates.push(new Date(d));
            }
            return dates;
        };

        const formatDate = (d) => {
            const dt = new Date(d);
            const month = `${dt.getMonth() + 1}`.padStart(2, '0');
            const day = `${dt.getDate()}`.padStart(2, '0');
            return `${dt.getFullYear()}-${month}-${day}`;
        };

        const Scheduler = () => {
            const saved = loadState();
            const baseDefaults = {
                language: 'en',
                employees: [{ id: 'emp-1', name: 'Employee 1' }, { id: 'emp-2', name: 'Employee 2' }],
                shifts: defaultShifts,
                requirements: defaultRequirements(),
                availability: {},
                preferences: {},
                schedule: {},
                workDays: [0,1,2,3,4,5,6],
                holidays: [],
                constraints: {
                    maxConsecutiveWorkDays: 5,
                    minConsecutiveWorkDays: 1,
                    maxConsecutiveRestDays: 3,
                    minConsecutiveRestDays: 1,
                    minWorkDaysBetweenRests: 0,
                    fairnessWeight: 10,
                },
                mode: 'month',
                month: new Date().getMonth(),
                year: new Date().getFullYear(),
                startDate: formatDate(new Date()),
                endDate: formatDate(new Date()),
                excelOptions: { office: '', preparer: '', headerColor: '#e2e8f0', headerText: '#0f172a' },
                viewOptions: { showTimes: true, fontSize: 12, cellPadding: 8, showWarnings: true },
            };

            const initial = saved ? {
                ...baseDefaults,
                ...saved,
                excelOptions: { ...baseDefaults.excelOptions, ...(saved.excelOptions || {}) },
                viewOptions: { ...baseDefaults.viewOptions, ...(saved.viewOptions || {}) },
            } : baseDefaults;

            const [state, setState] = useState(initial);
            const [activeTab, setActiveTab] = useState('schedule');
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');

            useEffect(() => {
                document.body.classList.toggle('rtl', state.language === 'ar');
            }, [state.language]);

            const t = (keyPath) => {
                const [root, child] = keyPath.split('.')
                if (child) return TRANSLATIONS[state.language]?.[root]?.[child] || keyPath;
                return TRANSLATIONS[state.language]?.[keyPath] || keyPath;
            };

            useEffect(() => { saveState(state); }, [state]);

            const enabledShifts = useMemo(() => state.shifts.filter(s => s.enabled), [state.shifts]);

            const dates = useMemo(() => {
                if (state.mode === 'range' && state.startDate && state.endDate) {
                    const res = [];
                    for (let d = new Date(state.startDate); d <= new Date(state.endDate); d.setDate(d.getDate() + 1)) {
                        res.push(formatDate(d));
                    }
                    return res;
                }
                const start = new Date(state.year, state.month, 1);
                const res = [];
                for (let d = new Date(start); d.getMonth() === state.month; d.setDate(d.getDate() + 1)) {
                    res.push(formatDate(d));
                }
                return res;
            }, [state.mode, state.startDate, state.endDate, state.month, state.year]);

            const handleShiftChange = (id, key, value) => {
                setState(prev => ({
                    ...prev,
                    shifts: prev.shifts.map(s => s.id === id ? { ...s, [key]: value } : s)
                }));
            };

            const addShift = () => {
                const id = `shift-${Date.now()}`;
                setState(prev => ({ ...prev, shifts: [...prev.shifts, { id, name: { en: 'New Shift', ar: 'ÙˆØ±Ø¯ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©' }, icon: 'â°', color: '#d1fae5', defaultStartTime: '08:00', defaultEndTime: '16:00', enabled: true }] }));
            };

            const handleRequirementChange = (dayIndex, shiftId, key, value) => {
                setState(prev => {
                    const req = [...prev.requirements];
                    const day = { ...(req[dayIndex] || {}) };
                    day[shiftId] = { ...(day[shiftId] || {}), [key]: value };
                    req[dayIndex] = day;
                    return { ...prev, requirements: req };
                });
            };

            const toggleWorkDay = (dayIndex) => {
                setState(prev => {
                    const set = new Set(prev.workDays);
                    if (set.has(dayIndex)) set.delete(dayIndex); else set.add(dayIndex);
                    return { ...prev, workDays: Array.from(set).sort() };
                });
            };

            const toggleHoliday = (date) => {
                setState(prev => {
                    const set = new Set(prev.holidays);
                    if (set.has(date)) set.delete(date); else set.add(date);
                    return { ...prev, holidays: Array.from(set) };
                });
            };

            const updateAvailability = (empId, date, updates) => {
                setState(prev => {
                    const avail = { ...prev.availability };
                    avail[empId] = { ...(avail[empId] || {}), [date]: { ...(avail[empId]?.[date] || {}), ...updates } };
                    return { ...prev, availability: avail };
                });
            };

            const updatePreferences = (empId, updates) => {
                setState(prev => {
                    const prefs = { ...prev.preferences, [empId]: { ...(prev.preferences[empId] || {}), ...updates } };
                    return { ...prev, preferences: prefs };
                });
            };

            const generateSchedule = () => {
                setLoading(true); setError('');
                setTimeout(() => {
                    const result = YALPS.solve({
                        dates,
                        employees: state.employees,
                        shifts: state.shifts,
                        requirements: state.requirements,
                        availability: state.availability,
                        preferences: state.preferences,
                        workDays: state.workDays,
                        holidays: state.holidays,
                        constraints: state.constraints,
                    });
                    if (!result.feasible) {
                        setError(state.language === 'ar' ? 'ØªØ¹Ø°Ø± Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ù‚ÙŠÙˆØ¯.' : 'Infeasible schedule with given constraints.');
                        setLoading(false);
                        return;
                    }
                    setState(prev => ({ ...prev, schedule: result.solution }));
                    setLoading(false);
                }, 50);
            };

            const clearSchedule = () => setState(prev => ({ ...prev, schedule: {} }));

            const exportCSV = () => {
                const rows = [];
                rows.push(['Date', 'Day', ...enabledShifts.map(s => s.name[state.language])].join(','));
                dates.forEach(date => {
                    const dayIdx = new Date(date).getDay();
                    const row = [date, daysShort[dayIdx]];
                    enabledShifts.forEach(shift => {
                        const names = (state.schedule[date]?.[shift.id] || []).map(id => state.employees.find(e => e.id === id)?.name || id).join(' | ');
                        row.push(`"${names}"`);
                    });
                    rows.push(row.join(','));
                });
                const blob = new Blob([rows.join('\n')], { type: 'text/csv;charset=utf-8;' });
                saveAs(blob, 'schedule.csv');
            };

            const exportExcel = async () => {
                const workbook = new ExcelJS.Workbook();
                const sheet = workbook.addWorksheet('Schedule');
                const lastColIndex = 2 + enabledShifts.length;
                const colLetter = String.fromCharCode('A'.charCodeAt(0) + lastColIndex - 1);
                const infoRow = sheet.addRow([state.excelOptions.office || '', '', '']);
                sheet.mergeCells(`A1:${colLetter}1`);
                infoRow.font = { bold: true, size: 14 };
                const prepRow = sheet.addRow([state.excelOptions.preparer ? `${state.excelOptions.preparer}` : '', '', '']);
                sheet.mergeCells(`A2:${colLetter}2`);
                prepRow.font = { size: 12 };

                const headerRow = sheet.addRow(['Date', 'Day', ...enabledShifts.map(s => s.name[state.language])]);
                headerRow.eachCell(cell => {
                    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: state.excelOptions.headerColor?.replace('#','') || 'e2e8f0' } };
                    cell.font = { color: { argb: state.excelOptions.headerText?.replace('#','') || '0f172a' }, bold: true };
                    cell.alignment = { horizontal: 'center', vertical: 'middle' };
                });

                dates.forEach(date => {
                    const row = [date, daysShort[new Date(date).getDay()]];
                    enabledShifts.forEach(shift => {
                        const names = (state.schedule[date]?.[shift.id] || []).map(id => state.employees.find(e => e.id === id)?.name || id).join(' | ');
                        row.push(names);
                    });
                    sheet.addRow(row);
                });
                sheet.columns.forEach(col => { col.width = 18; });
                await workbook.xlsx.writeBuffer().then(buffer => saveAs(new Blob([buffer]), 'schedule.xlsx'));
            };

            const scheduleView = () => (
                <div className="bg-white p-4 rounded-lg shadow">
                    <div className="flex items-center justify-between mb-4">
                        <div className="flex space-x-2 rtl:space-x-reverse">
                            <button onClick={() => setActiveTab('schedule')} className={`px-3 py-2 rounded ${activeTab==='schedule'?'bg-slate-900 text-white':'bg-slate-100'}`}>{t('tabs.schedule')}</button>
                            <button onClick={() => setActiveTab('availability')} className={`px-3 py-2 rounded ${activeTab==='availability'?'bg-slate-900 text-white':'bg-slate-100'}`}>{t('tabs.availability')}</button>
                            <button onClick={() => setActiveTab('employees')} className={`px-3 py-2 rounded ${activeTab==='employees'?'bg-slate-900 text-white':'bg-slate-100'}`}>{t('tabs.employees')}</button>
                            <button onClick={() => setActiveTab('settings')} className={`px-3 py-2 rounded ${activeTab==='settings'?'bg-slate-900 text-white':'bg-slate-100'}`}>{t('tabs.settings')}</button>
                            <button onClick={() => setActiveTab('export')} className={`px-3 py-2 rounded ${activeTab==='export'?'bg-slate-900 text-white':'bg-slate-100'}`}>{t('tabs.export')}</button>
                        </div>
                        <div className="flex space-x-2 rtl:space-x-reverse">
                            <button onClick={generateSchedule} className="px-3 py-2 bg-emerald-600 text-white rounded" disabled={loading}>{loading?t('generate')+'...':t('generate')}</button>
                            <button onClick={clearSchedule} className="px-3 py-2 bg-slate-200 rounded">{t('clear')}</button>
                        </div>
                    </div>
                    {error && <div className="p-2 bg-rose-100 text-rose-700 rounded mb-4">{error}</div>}
                    <div className="overflow-auto custom-scroll">
                        <table className="min-w-full" style={{ fontSize: `${state.viewOptions.fontSize}px` }}>
                            <thead>
                                <tr className="bg-slate-100">
                                    <th className="border" style={{ padding: state.viewOptions.cellPadding }}>Date</th>
                                    <th className="border" style={{ padding: state.viewOptions.cellPadding }}>Day</th>
                                    {enabledShifts.map(shift => (
                                        <th key={shift.id} className="border" style={{ background: shift.color, padding: state.viewOptions.cellPadding }}>
                                            <div className="flex items-center space-x-1 rtl:space-x-reverse justify-center">
                                                <span>{shift.icon}</span>
                                                <span>{shift.name[state.language]}</span>
                                                {state.viewOptions.showTimes && <span className="text-xs text-slate-600">({shift.defaultStartTime} - {shift.defaultEndTime})</span>}
                                            </div>
                                        </th>
                                    ))}
                                </tr>
                            </thead>
                            <tbody>
                                {dates.map(date => (
                                    <tr key={date} className="even:bg-slate-50">
                                        <td className="border font-medium" style={{ padding: state.viewOptions.cellPadding }}>{date}</td>
                                        <td className="border" style={{ padding: state.viewOptions.cellPadding }}>{daysShort[new Date(date).getDay()]}</td>
                                        {enabledShifts.map(shift => (
                                            <td key={shift.id} className="border" style={{ background: `${shift.color}55`, padding: state.viewOptions.cellPadding }}>
                                                <div className="space-y-1">
                                                    {(state.schedule[date]?.[shift.id] || []).map(empId => (
                                                        <div key={empId} className="px-2 py-1 rounded bg-white shadow-sm">
                                                            {state.employees.find(e => e.id === empId)?.name || empId}
                                                        </div>
                                                    ))}
                                                </div>
                                            </td>
                                        ))}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );

            const availabilityView = () => (
                <div className="bg-white p-4 rounded-lg shadow space-y-4">
                    <h2 className="text-lg font-semibold">{t('availability')}</h2>
                    <div className="overflow-auto custom-scroll">
                        <table className="min-w-full text-sm">
                            <thead className="bg-slate-100">
                                <tr>
                                    <th className="border px-2 py-2">Employee</th>
                                    {dates.map(date => (
                                        <th key={date} className="border px-2 py-1 text-xs w-28">{date}</th>
                                    ))}
                                </tr>
                            </thead>
                            <tbody>
                                {state.employees.map(emp => (
                                    <tr key={emp.id} className="even:bg-slate-50">
                                        <td className="border px-2 py-2 font-medium w-40">{emp.name}</td>
                                        {dates.map(date => {
                                            const day = state.availability[emp.id]?.[date] || {};
                                            return (
                                                <td key={date} className="border px-2 py-1">
                                                    <select value={day.status || 'available'} onChange={(e) => updateAvailability(emp.id, date, { status: e.target.value })} className="w-full text-xs border rounded px-1 py-0.5">
                                                        <option value="available">Available</option>
                                                        <option value="unavailable">Unavailable</option>
                                                        <option value="restricted">Allowed Shifts</option>
                                                    </select>
                                                    {day.status === 'restricted' && (
                                                        <div className="flex flex-wrap gap-1 mt-1">
                                                            {state.shifts.map(shift => (
                                                                <label key={shift.id} className="text-[10px] inline-flex items-center space-x-1 rtl:space-x-reverse">
                                                                    <input type="checkbox" checked={(day.allowedShifts || []).includes(shift.id)} onChange={(e) => {
                                                                        const current = new Set(day.allowedShifts || []);
                                                                        if (e.target.checked) current.add(shift.id); else current.delete(shift.id);
                                                                        updateAvailability(emp.id, date, { allowedShifts: Array.from(current) });
                                                                    }} />
                                                                    <span>{shift.name[state.language]}</span>
                                                                </label>
                                                            ))}
                                                        </div>
                                                    )}
                                                </td>
                                            );
                                        })}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                    <div className="space-y-2">
                        <h3 className="font-semibold">Preferences</h3>
                        {state.employees.map(emp => {
                            const pref = state.preferences[emp.id] || {};
                            return (
                                <div key={emp.id} className="p-2 border rounded">
                                    <div className="font-medium mb-1">{emp.name}</div>
                                    <div className="flex flex-wrap gap-2 items-center">
                                        <span className="text-sm">Preferred Shifts:</span>
                                        {state.shifts.map(shift => (
                                            <label key={shift.id} className="text-xs inline-flex items-center space-x-1 rtl:space-x-reverse">
                                                <input type="checkbox" checked={pref.preferredShifts?.includes(shift.id) || false} onChange={(e) => {
                                                    const set = new Set(pref.preferredShifts || []);
                                                    if (e.target.checked) set.add(shift.id); else set.delete(shift.id);
                                                    updatePreferences(emp.id, { preferredShifts: Array.from(set) });
                                                }} />
                                                <span>{shift.name[state.language]}</span>
                                            </label>
                                        ))}
                                    </div>
                                    <div className="flex flex-wrap gap-2 items-center mt-2">
                                        <span className="text-sm">Priority Days:</span>
                                        {daysFull.map((d, idx) => (
                                            <label key={d} className="text-xs inline-flex items-center space-x-1 rtl:space-x-reverse">
                                                <input type="checkbox" checked={pref.priorityDays?.includes(idx) || false} onChange={(e) => {
                                                    const set = new Set(pref.priorityDays || []);
                                                    if (e.target.checked) set.add(idx); else set.delete(idx);
                                                    updatePreferences(emp.id, { priorityDays: Array.from(set) });
                                                }} />
                                                <span>{d}</span>
                                            </label>
                                        ))}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );

            const employeesView = () => (
                <div className="bg-white p-4 rounded-lg shadow space-y-4">
                    <div className="flex items-center justify-between">
                        <h2 className="text-lg font-semibold">{t('employees')}</h2>
                        <button onClick={() => setState(prev => ({ ...prev, employees: [...prev.employees, { id: `emp-${Date.now()}`, name: 'New Employee' }] }))} className="px-3 py-1 bg-slate-900 text-white rounded">{t('addEmployee')}</button>
                    </div>
                    <div className="space-y-2">
                        {state.employees.map(emp => (
                            <div key={emp.id} className="flex items-center space-x-2 rtl:space-x-reverse">
                                <input value={emp.name} onChange={(e) => setState(prev => ({ ...prev, employees: prev.employees.map(x => x.id === emp.id ? { ...x, name: e.target.value } : x) }))} className="border rounded px-2 py-1 flex-1" />
                                <button onClick={() => setState(prev => ({ ...prev, employees: prev.employees.filter(x => x.id !== emp.id) }))} className="px-2 py-1 bg-rose-100 text-rose-700 rounded">{t('remove')}</button>
                            </div>
                        ))}
                    </div>
                </div>
            );

            const settingsView = () => (
                <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
                    <div className="bg-white p-4 rounded-lg shadow space-y-4">
                        <div className="flex items-center justify-between">
                            <h2 className="text-lg font-semibold">{t('shifts')}</h2>
                            <button onClick={addShift} className="px-3 py-1 bg-emerald-600 text-white rounded">{t('addShift')}</button>
                        </div>
                        <div className="space-y-3">
                            {state.shifts.map(shift => (
                                <div key={shift.id} className="border rounded p-3 space-y-2">
                                    <div className="flex items-center space-x-2 rtl:space-x-reverse">
                                        <input value={shift.icon} onChange={e => handleShiftChange(shift.id, 'icon', e.target.value)} className="w-16 border rounded px-2 py-1" />
                                        <input value={shift.name.en} onChange={e => handleShiftChange(shift.id, 'name', { ...shift.name, en: e.target.value })} className="border rounded px-2 py-1 flex-1" />
                                        <input value={shift.name.ar} onChange={e => handleShiftChange(shift.id, 'name', { ...shift.name, ar: e.target.value })} className="border rounded px-2 py-1 flex-1" />
                                        <label className="flex items-center space-x-1 rtl:space-x-reverse text-sm">
                                            <input type="checkbox" checked={shift.enabled} onChange={e => handleShiftChange(shift.id, 'enabled', e.target.checked)} />
                                            <span>Enabled</span>
                                        </label>
                                    </div>
                                    <div className="flex items-center space-x-2 rtl:space-x-reverse">
                                        <label className="text-sm">Start <input type="time" value={shift.defaultStartTime} onChange={e => handleShiftChange(shift.id, 'defaultStartTime', e.target.value)} className="border rounded px-2 py-1 ml-2" /></label>
                                        <label className="text-sm">End <input type="time" value={shift.defaultEndTime} onChange={e => handleShiftChange(shift.id, 'defaultEndTime', e.target.value)} className="border rounded px-2 py-1 ml-2" /></label>
                                        <label className="text-sm">Color <input type="color" value={shift.color} onChange={e => handleShiftChange(shift.id, 'color', e.target.value)} className="ml-2" /></label>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                    <div className="bg-white p-4 rounded-lg shadow space-y-4">
                        <h2 className="text-lg font-semibold">{t('requirements')}</h2>
                        <div className="space-y-3">
                            {daysFull.map((day, idx) => (
                                <div key={day} className="border rounded p-3 space-y-2">
                                    <div className="flex items-center justify-between">
                                        <div className="font-medium">{day}</div>
                                        <label className="flex items-center space-x-1 rtl:space-x-reverse text-sm">
                                            <input type="checkbox" checked={state.workDays.includes(idx)} onChange={() => toggleWorkDay(idx)} />
                                            <span>{t('workDay')}</span>
                                        </label>
                                    </div>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                                        {state.shifts.map(shift => (
                                            <div key={shift.id} className="border rounded p-2 space-y-1">
                                                <div className="flex items-center justify-between text-sm font-medium"><span>{shift.icon} {shift.name[state.language]}</span></div>
                                                <label className="text-xs">Required Count <input type="number" min="0" value={state.requirements[idx]?.[shift.id]?.requiredCount || 0} onChange={e => handleRequirementChange(idx, shift.id, 'requiredCount', Number(e.target.value))} className="border rounded px-2 py-1 w-full" /></label>
                                                <label className="text-xs">Start <input type="time" value={state.requirements[idx]?.[shift.id]?.startTime || shift.defaultStartTime} onChange={e => handleRequirementChange(idx, shift.id, 'startTime', e.target.value)} className="border rounded px-2 py-1 w-full" /></label>
                                                <label className="text-xs">End <input type="time" value={state.requirements[idx]?.[shift.id]?.endTime || shift.defaultEndTime} onChange={e => handleRequirementChange(idx, shift.id, 'endTime', e.target.value)} className="border rounded px-2 py-1 w-full" /></label>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                        <div className="grid grid-cols-2 gap-3">
                            <label className="text-sm">Max Consecutive Work Days <input type="number" min="1" value={state.constraints.maxConsecutiveWorkDays} onChange={e => setState(prev => ({ ...prev, constraints: { ...prev.constraints, maxConsecutiveWorkDays: Number(e.target.value) } }))} className="border rounded px-2 py-1 w-full" /></label>
                            <label className="text-sm">Min Consecutive Work Days <input type="number" min="0" value={state.constraints.minConsecutiveWorkDays} onChange={e => setState(prev => ({ ...prev, constraints: { ...prev.constraints, minConsecutiveWorkDays: Number(e.target.value) } }))} className="border rounded px-2 py-1 w-full" /></label>
                            <label className="text-sm">Max Consecutive Rest Days <input type="number" min="1" value={state.constraints.maxConsecutiveRestDays} onChange={e => setState(prev => ({ ...prev, constraints: { ...prev.constraints, maxConsecutiveRestDays: Number(e.target.value) } }))} className="border rounded px-2 py-1 w-full" /></label>
                            <label className="text-sm">Min Consecutive Rest Days <input type="number" min="0" value={state.constraints.minConsecutiveRestDays} onChange={e => setState(prev => ({ ...prev, constraints: { ...prev.constraints, minConsecutiveRestDays: Number(e.target.value) } }))} className="border rounded px-2 py-1 w-full" /></label>
                            <label className="text-sm">Min Work Days Between Rests <input type="number" min="0" value={state.constraints.minWorkDaysBetweenRests} onChange={e => setState(prev => ({ ...prev, constraints: { ...prev.constraints, minWorkDaysBetweenRests: Number(e.target.value) } }))} className="border rounded px-2 py-1 w-full" /></label>
                        </div>
                        <div className="space-y-2">
                            <div className="font-semibold">{t('holidays')}</div>
                            <div className="flex flex-wrap gap-2">
                                {state.holidays.map(h => (
                                    <span key={h} className="px-2 py-1 bg-amber-100 text-amber-700 rounded inline-flex items-center space-x-1 rtl:space-x-reverse">
                                        <span>{h}</span>
                                        <button onClick={() => toggleHoliday(h)} className="text-xs">âœ•</button>
                                    </span>
                                ))}
                            </div>
                            <div className="flex items-center space-x-2 rtl:space-x-reverse">
                                <input type="date" value={state.__holidayDraft || ''} onChange={e => setState(prev => ({ ...prev, __holidayDraft: e.target.value }))} className="border rounded px-2 py-1" />
                                <button onClick={() => state.__holidayDraft && toggleHoliday(state.__holidayDraft)} className="px-3 py-1 bg-amber-500 text-white rounded">{t('addHoliday')}</button>
                            </div>
                        </div>
                    </div>
                    <div className="bg-white p-4 rounded-lg shadow space-y-3 lg:col-span-2">
                        <h2 className="text-lg font-semibold">{t('viewSettings')}</h2>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                            <label className="text-sm flex flex-col">{t('fontSize')}
                                <input type="number" min="8" max="24" value={state.viewOptions.fontSize} onChange={e => setState(prev => ({ ...prev, viewOptions: { ...prev.viewOptions, fontSize: Number(e.target.value) } }))} className="border rounded px-2 py-1 mt-1" />
                            </label>
                            <label className="text-sm flex flex-col">{t('cellPadding')}
                                <input type="number" min="4" max="24" value={state.viewOptions.cellPadding} onChange={e => setState(prev => ({ ...prev, viewOptions: { ...prev.viewOptions, cellPadding: Number(e.target.value) } }))} className="border rounded px-2 py-1 mt-1" />
                            </label>
                            <label className="text-sm flex items-center space-x-2 rtl:space-x-reverse">
                                <input type="checkbox" checked={state.viewOptions.showTimes} onChange={e => setState(prev => ({ ...prev, viewOptions: { ...prev.viewOptions, showTimes: e.target.checked } }))} />
                                <span>{t('showTimes')}</span>
                            </label>
                            <label className="text-sm flex items-center space-x-2 rtl:space-x-reverse">
                                <input type="checkbox" checked={state.viewOptions.showWarnings} onChange={e => setState(prev => ({ ...prev, viewOptions: { ...prev.viewOptions, showWarnings: e.target.checked } }))} />
                                <span>{t('showWarnings')}</span>
                            </label>
                        </div>
                    </div>
                </div>
            );

            const exportView = () => (
                <div className="bg-white p-4 rounded-lg shadow space-y-4">
                    <h2 className="text-lg font-semibold">{t('export')}</h2>
                    <div className="flex space-x-2 rtl:space-x-reverse">
                        <button onClick={exportCSV} className="px-3 py-2 bg-slate-900 text-white rounded">{t('exportCsv')}</button>
                        <button onClick={exportExcel} className="px-3 py-2 bg-emerald-600 text-white rounded">{t('exportExcel')}</button>
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                        <label className="text-sm flex flex-col">{t('office')}
                            <input value={state.excelOptions.office || ''} onChange={e => setState(prev => ({ ...prev, excelOptions: { ...prev.excelOptions, office: e.target.value } }))} className="border rounded px-2 py-1 mt-1" />
                        </label>
                        <label className="text-sm flex flex-col">{t('preparer')}
                            <input value={state.excelOptions.preparer || ''} onChange={e => setState(prev => ({ ...prev, excelOptions: { ...prev.excelOptions, preparer: e.target.value } }))} className="border rounded px-2 py-1 mt-1" />
                        </label>
                        <label className="text-sm flex flex-col">{t('headerColor')}
                            <input type="color" value={state.excelOptions.headerColor || '#e2e8f0'} onChange={e => setState(prev => ({ ...prev, excelOptions: { ...prev.excelOptions, headerColor: e.target.value } }))} className="mt-1" />
                        </label>
                        <label className="text-sm flex flex-col">{t('headerText')}
                            <input type="color" value={state.excelOptions.headerText || '#0f172a'} onChange={e => setState(prev => ({ ...prev, excelOptions: { ...prev.excelOptions, headerText: e.target.value } }))} className="mt-1" />
                        </label>
                    </div>
                </div>
            );

            const dateControls = (
                <div className="bg-white p-4 rounded-lg shadow mb-4 grid grid-cols-1 md:grid-cols-3 gap-3">
                    <label className="text-sm flex flex-col">Mode
                        <select value={state.mode} onChange={e => setState(prev => ({ ...prev, mode: e.target.value }))} className="border rounded px-2 py-1 mt-1">
                            <option value="month">Month</option>
                            <option value="range">Range</option>
                        </select>
                    </label>
                    {state.mode === 'month' ? (
                        <>
                            <label className="text-sm flex flex-col">Month
                                <select value={state.month} onChange={e => setState(prev => ({ ...prev, month: Number(e.target.value) }))} className="border rounded px-2 py-1 mt-1">
                                    {Array.from({ length: 12 }).map((_, i) => <option key={i} value={i}>{i + 1}</option>)}
                                </select>
                            </label>
                            <label className="text-sm flex flex-col">Year
                                <input type="number" value={state.year} onChange={e => setState(prev => ({ ...prev, year: Number(e.target.value) }))} className="border rounded px-2 py-1 mt-1" />
                            </label>
                        </>
                    ) : (
                        <>
                            <label className="text-sm flex flex-col">Start Date
                                <input type="date" value={state.startDate} onChange={e => setState(prev => ({ ...prev, startDate: e.target.value }))} className="border rounded px-2 py-1 mt-1" />
                            </label>
                            <label className="text-sm flex flex-col">End Date
                                <input type="date" value={state.endDate} onChange={e => setState(prev => ({ ...prev, endDate: e.target.value }))} className="border rounded px-2 py-1 mt-1" />
                            </label>
                        </>
                    )}
                    <label className="text-sm flex items-center space-x-2 rtl:space-x-reverse">{t('showTimes')}
                        <input type="checkbox" checked={state.viewOptions.showTimes} onChange={e => setState(prev => ({ ...prev, viewOptions: { ...prev.viewOptions, showTimes: e.target.checked } }))} />
                    </label>
                </div>
            );

            return (
                <div className="max-w-7xl mx-auto p-4 space-y-4">
                    <div className="flex items-center justify-between">
                        <h1 className="text-2xl font-bold">{t('title')}</h1>
                        <select value={state.language} onChange={e => setState(prev => ({ ...prev, language: e.target.value }))} className="border rounded px-2 py-1">
                            <option value="en">English</option>
                            <option value="ar">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
                        </select>
                    </div>
                    {dateControls}
                    {activeTab === 'schedule' && scheduleView()}
                    {activeTab === 'availability' && availabilityView()}
                    {activeTab === 'employees' && employeesView()}
                    {activeTab === 'settings' && settingsView()}
                    {activeTab === 'export' && exportView()}
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<Scheduler />);
    </script>
</body>
</html>
